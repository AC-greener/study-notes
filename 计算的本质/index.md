#### 第二章、程序的含义

为了完整地定义编程语言，我们需要：语法，描述程序看起来是什么样的；

语义（semantics） ，描述程序的含义

语法解析器应该读入像 y = x + 1这样的字符串，然后把它转换成抽象语法树（AST）。抽象语法树是源代码的一种表示，去掉了空格之类的无关细节，而只关注程序的分层结构

##### 操作语义

操作语义学（operational semantic）的基础，在运行程序的时候，我们期望发生什么呢？在运行时编程语言中不同的结构都是如何表现的？把它们放到一起组成更大的程序时会是什么效果

###### 小步语义

按照语法进行操作一小步一小步地对其进行**反复规约**，从而对一个程序求值。不管最后得到的结果含义是什么，我们每一步都能让程序更接近最终结果。

小步操作语义是什么样子的：设计一台抽象机器维护一些执行状态，然后定义一些规约规则，这些规则详细说明了如何才能对每种程序结构循序渐进地求值。特别地，小步语义大部分都带有迭代的味道，它要求抽象机器反复执行规约步骤，这些步骤以及与它们同样类型的信息可以作为自身的输入和输出，这让它们适合这种反复进行的应用程序。

优缺点：就是能把执行程序的复杂过程分成更小的片段解释和分析，但它确实有点不够直接：我们没有解释整个程序结构是如何工作的，而只是展示了它是如何慢慢规约的

###### 大步语义

大步语义的思想是，定义如何从一个表达式或者语句直接得到它的结果。这必然需要把程序的执行**当成一个递归的而不是迭代的过程**：大步语义说的是，为了对一个更大的表达式求值，我们要对所有比它小的子表达式求值，然后把结果结合起来得到最终答案。

在很多方面，这都比小步的方法更自然，但确实失去了一些对细节的关注。例如，小步语义明确定义了操作应该发生的顺序，因为在每一步都明确了下一步规约应该是什么。但是大步语义经常会写成更为松散的形式，只会说哪些子计算会执行，而不会指明它们按什么顺序执行。

操作语义实质上是这样的：通过描述一个解析器来说明一种语言的含义。

##### 指称语义

指称语义关心从程序本来的语言到其他表示的转换。

吧Simple转换成Ruby并且可以用eval执行

这种类型的语义没有直接处理程序的执行，而是关注如何借助另一种语言的已有含义——一种低级的、更形式化的或者至少比正在描述的语言更好理解的语言——解释一个新的语言。

##### 形式化语义实践