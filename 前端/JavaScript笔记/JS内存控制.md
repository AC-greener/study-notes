### 内存控制

- 由于v8的内存限制：在node中通过js可以使用的内存为1.4G或0.7G，无法操作大内存对象
- 垃圾回收算法
  - 回收策略主要基于分代式垃圾回收机制：按对象的存活时间分为新生代对象（存活时间短）和老生代对象
  - Scavenge算法（回收新生代对象）
    - 将堆内存一分为二，一个空间处于使用中，称为From空间，另一个处于闲置状态称为To空间，当我们分配对象时，现在from对象中分配，当开始垃圾回收时，会检查from中的存活对象，非存活对象占用的空间会被释放，存活对象将被复制到To空间中，完成复制后，from空间和to空间的角色发生互换
    - 缺点是只能使用堆内存的一半
    - 一个对象经过多次复制仍然存活，会被认为是生命周期较长的对象，就会晋升，从新生代移动到老生代中
  - Mark-sweep && Mark-compact算法
    - Mark-sweep 在标记阶段遍历堆中的所有对象，并标记或者的对象，在随后的清楚阶段中，只清楚没有被标记的对象
    - 缺点是在进行一次标记清楚后，内存空间会出现不连续的状态，如果随后需要分配一个大内存，这时所有的碎片空间都不够分配，就会提前出发垃圾回收，但是这次回收是不必要的
    - Mark-compact是标记整理，区别在对象呗标记为死亡之后，在整理的过程中，将或者的对象往一端移动，移动完成后会直接清理掉边界外的内存
  - Incremental  Marking
    - 为了防止js的执行和垃圾回收看到的情况不一致，在进行垃圾回收时，js的执行会停止，js代码会等到垃圾回收完成之后在执行，也叫做全停顿
    - 因为新生代一般比较小，全停顿的影响不大，但老生代的占用内存较大，全停顿会造成一些问题
    - v8引入了增量标记，将原本一口气停顿完成的动作改为增量标记，也就是垃圾回收和js逻辑执行交替进行，直到标记完成。引入增量标记之后，垃圾回收的最大停顿时间减少到原来的1/6左右
      - v8 后续还引入了延迟清理（lazy sweeping）和增量式·						整理（incremental compaction）
- 在js中无法立即回收的内存有全局变量和闭包

##### 内存泄露的原因：

- 缓存
  - 一旦一个对象被当作缓存，他就会进入老生代中，缓存中存储的键越多，长期存活的对象也就越多，这导致垃圾回收进行扫描时，对这些对象做无用功
  - 缓存限制策略：可以通过键值对的数量来限制缓存，一旦超过数量就以先进先出的方式淘汰，更高效的淘汰策略：LRU算法
  - 使用大量缓存的解决方案：采用进程外的缓存
- 队列消费不及时
  - 队列经常使用在消费-生产者模型中，一旦消费速度低于生产速度，就会形成堆积
  - 解决方案：
    - 换用消费速度更高的技术
    - 监控队列长度
    - 异步调用应该包含超时机制
- 作用域未释放

##### 内存泄漏排查工具

- node-heapdump
- node-memwatch









