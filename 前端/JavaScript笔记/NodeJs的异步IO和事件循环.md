## NodeJs的异步IO和事件循环

1. node擅长IO密集的应用场景，IO密集的主要优势在于node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少
2. 假设业务场景中有一组互不相关的任务需要完成，有两种主要的方法：
   1. 单线程串行执行，他的缺点在于性能，任意一个略慢的任务都会导致后续执行代码被阻塞
   2. 多线程并行，多线程的代价在于创建线程和执行器线程上下文切换开销较大，而且多线程经常面临锁，状态同步等问题，但是多线程在多核cpu上能够提升cpu的利用率
3. node在两者之间给出了他的方案：利用单线程避免死锁，状态同步等问题，利用异步IO，让单线程远离阻塞，为了弥补单线程无法利用多核cpu的缺点，node提供了类似前端中web worker子进程child_process，改子进程可以通过工作进程高效的利用CPU和IO
4. **注意：**平常我们提到的node是单线程的，这里的单线程仅仅是js执行在单线程中罢了，在node中，内部完成的所有IO另有线程池，是可以并行执行的

#### 异步IO的环节

1. ##### 事件循环

   1. 事件循环是 Node.js 处理非阻塞 I/O 操作的机制
   2. 在进程启动时，node便会创建一个类似于while(true)的循环，每执行一次循环的的过程叫做Tick，每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件相关的回调函数，然后继续进行循环，如果不在有事件处理，就退出进程![1563937427275](C:\Users\i-zhutongtong\AppData\Roaming\Typora\typora-user-images\1563937427275.png)
   3. 每个阶段都有一个 FIFO 队列来执行回调。当事件循环进入给定的阶段时，会在该阶段的队列中执行回调，直到队列用尽或达到回调的限制，事件循环将移动到下一阶段。
      1. **timers**：本阶段执行过期的的 `setTimeout()` 和 `setInterval()` 的回调函数。
      2. **pending **：仅供系统使用
      3. **idle prepare**：仅供系统使用
      4. **poll轮询**：I/O 的回调函数在此阶段执行
      5. **check观察者**：`setImmediate` 回调函数在这里执行。
      6. **close callback**：一些准备关闭的回调函数，如：`socket.on('close', ...)`。

2. ##### 观察者

   1. 在每个Tick中如何判断是否有事件需要处理呢？就用到了观察者，会向这些观察者询问是否有需要处理的事件
   2. 事件循环中有多个观察者，不同的事件对应不同的观察者，有文件IO观察者，网络IO观察者，idle观察者，check观察者。在每一轮循环检查中idle观察者先于IO观察者，IO观察者先于check观察者
   3. 事件循环是一个典型的生产者消费者模型，异步IO、网络请求是事件的生产者，为node提供事件，这些事件被传到观察者哪里，然后事件循环则从观察者哪里取出事件处理。
   4. 在具体的实现上nextTick的回调函数保存在一个数组中，setImmediate的回掉保存在链表中，nextTick每轮循环会将数组中全部的回调函数执行完，而setImmediate每轮循环只执行链表中的一个回调函数。

   - `setImmediate()` 设计为在当前 **轮询** 阶段完成后执行脚本。
   - `setTimeout()` 计划在毫秒的最小阈值经过后运行的脚本。
   - `process.nextTick()` 在技术上不是事件循环的一部分。但是，当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，会先清空这个队列里面的回调。