#### 前端架构笔记

不建议看，五分的话只能给一分，通读下来可以对前端开发的整个流程有所了解

1. 好多内容的浅尝辄止，讲的有点泛
2. 作者在第10章谈到了模式驱动设计，没有读懂
3. 书中的很多内容都已经过时了，比如打包工具Grunt，现在基本上都是用webpack来代替了，原版是在2016年出版的，可能和时间也有一些关系吧

1. 模块化内容，希望尽可能复用小的组件
2. 全面测试：我们之前经常出现这样的情况：大量的前端代码合入到主干，然后导致几个月前的代码出现运行问题。这样太浪费时间了，所以我们决定要像测试后端代码一样测试我们的新框架，达到一样的代码覆盖水平。
3. 流式处理：把过去一直采用的容易出错的手动步骤自动化：更新样式表、创建图标字体、部署新代码等。
4. 详细的文档。包括前端开发人员、后端开发人员、设计师、市场经理、运维人员，以及其他产品开发角色。我们希望每个人接触这套系统时，都能找到适合自己的、详细的文档。

##### 1、前端架构和核心

1. 代码
2. 流程。思考怎么用工具和流程构建一个高效且避免出错的工作流。工作流变得越来越复杂，那些用于构建它们的工具也同样如此。这些工具在提高生产力、加快效率和保持代码一致性上带来了惊人的效果，但也伴随着过度工程化和抽象化的风险。
3. 测试
4. 文档。一般而言，如果不是团队中的重要成员要离开，我们几乎都不会意识到文档的重要性。等到那个时候，大家将不得不停下手头的工作，优先编写所有的文档。作为前端架构师，你要善于在项目开发的同时编写良好的文档。

开发人员意见纷纭是很正常的。这种从不同角度看待问题的能力使得我们团队越来越强大。但是在输出方案并且实际应用于设计系统的时候，我们既不希望也不需要在程序中反映出这些差异。

##### 2、CSS设计

使用扁平化的选择器，这样可以停止CSS优先级之间的冲突问题，让每一个选择器的权重扁平化成1

区分布局与组件的角色和职责

**模块化CSS**

SMACSS（Scalable and Modular Architecture for CSS，模块化架构的可扩展CSS）
SMACSS吧样式系统划分为几个具体类别。

1. 基础，如果不添加CSS类名，标记会以什么外观呈现。
2. 布局，把页面分成一些区域。
3. 模块，设计中的模块化、可复用的单元。
4. 状态，描述在特定的状态或情况下，模块或布局的显示方式。
5. 主题，一个可选的视觉外观层，可以让你更换不同主题
   ![1592992887975](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1592992887975.png)

BEM方法
BEM只是一个CSS类名命名规则。它不涉及如何书写你的CSS的结构，只是建议每个元素都添加带有如下内容的CSS类名。

1. ​	aaa

1. 块名所属组件的名称。
2. 元素元素在块里面的名称。
3. 修饰符任何与块或元素相关联的修饰符。
   ![1592993197490](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1592993197490.png)





类名要保持单一职责原则
下面是一个错误的例子
![1592993997310](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1592993997310.png)
![1592994113238](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1592994113238.png)

##### 3、JS设计与原则

1. 运用eslint进行强校验
   1. ·强制使用===和!== 代替==和!=·
   2. 限制代码块嵌套深度·
   3. 限制函数的参数数量·
   4. 如果函数重复定义，发出警告·
   5. 如果变量创建后未被使用，发出警告
2. 将代码拆分成小块，使用可复用的函数

##### 4、组件和布局

对组件进行分类

制定规范

1. ·只包含不可变的规则，而不是笼统的说明·
2. 总是把规则提炼成最简单的表达·
3. 总是首先说明规则是什么，再说明“如果不这样，那么会如何”·
4. 每个规则必须包含以下词中的一个——总是、永远不要、只有、每一个、不要、要

一些规则：

1. ·永远不要给布局的子内容强加内边距和元素样式。布局只关注垂直对齐、水平对齐和文字间距。
2. ·主题和别的数据属性值永远不要强制改变外观；它们必须保持布局、组件和元素可以应用于其上。
3. ·组件总是贴着它的父容器的四个边，元素都没有上外边距和左外边距，所有的最后节点（最右边和最下边的节点）的外边距都会被清除。
4. ·组件本身永远不要添加背景、宽度、浮动、内边距和外边距的样式，组件样式是组件内元素的样式。
5. ·每个元素都有且只有一个唯一的且作用域只在组件内的CSS类名。所有的样式都是直接应用到这个选择器上，并且只有上下文和主题能修改元素的样式。
6. ·永远不要在元素上使用上外边距，第一个元素总是贴着它所在组件的顶部。
7. ·JavaScript永远不要绑定任何元素的CSS类名，选中元素通过数据属性实现。

每个标签指定唯一的选择器



可以使用标签的数据属性来代替选择器的修饰符

```html
<div class='nav' data-bar='active'>
</div>
[data-bar='active'] {
	background: red
}
```

使用数据属性进行布局

可选的上下文：组件可以根据所在的父级元素或者父级元素的某些数据属性来改变自身的表现

```css
[data-theme='dark']
.context-icon {
  color: white;
}
[data-theme='light']
.context-icon {
  color: black;
}
```

![1593069258830](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1593069258830.png)

##### 5、工作流核心

工作流：需求---原型---开发

前端工作流：

1. 安装必要的软件环境
2. 本地部署项目
3. 软件开发
4. 持续集成

##### 6、测试核心

1. ·测试用例应该在建站的同时，甚至在建站之前就开始编写。
2. ·测试代码是真实的代码，应该一起或立即提交到系统代码库中。
3. ·必须在所有的测试用例都通过之后，才能把代码合并到主干中。
4. ·在主干上运行测试工具，结果应该都为通过。

###### 单元测试

单元测试是将应用程序分解为尽可能小的函数，并创建可重复的、自动化的测试用例的过程。在同等条件下，这些测试用例应该一直产生相同的结果，它们是应用程序的灵魂，并为今后所有应用程序的代码提供构建的基础。

测试覆盖率：

确定合适的测试覆盖率是很难权衡的一件事情。如果你不是在进行测试驱动的开发（这种开发中，没有代码是不需要单元测试的），那么确定测试覆盖率将非常重要。如果测试所有的代码，开发进度可能停滞不前；而如果测试不够，就有漏掉新问题的风险。

###### 性能测试，性能优化

性能测试的关键指标

1. 页面大小、
2. 请求数量、
3. 首字节时间（time to first byte，TTFB）、
4. 加载时间
5. 滚动性能。

**缩减页面大小的手段**

1. ·图片占据页面平均大小的61%。
   1. 优化PNG图片，并降低JPEG图片的质量。
   2. 利用新的响应式的<picture> 标记和**srcset**属性来下载大小合适的图片。
   3. 制定一个预算，如果没有移除任何图片，就不增加图片大小。·
2. 太多自定义字体很快会使网页变得臃肿。
   1. 制定一个字体预算，不考虑增加第二种或第三种字体。
   2. 考虑必要的字体粗细，因为每增加一种粗细变化，都会使字体文件增加几千个字节。
   3. 使用svg代表图标字体

**HTTP请求次数**

1. 减少HTTP请求的次数。
   1. 不要提供数十个单独的CSS文件和JavaScript文件，而是把它们合并到一个文件中。
   2. 把多个单独的图像文件合并成一个图像映射或者图标字体
   3. 延迟加载页面最初加载所不需要的资源。这可能是直到用户与页面交互才需要的JavaScript文件，也可能是初始加载窗口之下距离较远的图片。
2. ·增加浏览器每次并发请求的资源个数。
   1. 分拆你的资源到不同的服务器（或者CDN），可以使得浏览器单次并发下载更多的资源，因为浏览器的并发请求数量限制是针对单个服务器的。

**计时度量**

首字节时间

首字节时间是指从浏览器请求网站页面开始，到浏览器接收到第一个字节之间的毫秒数。这个数值用来测量浏览器和服务器之间的连通路径，包括DNS查询、初始连接和数据接收。它并不是判断站点性能的最佳标准，却是一个值得关注的指标。

开始渲染时间

更有价值的计时度量是“开始渲染时间”。这个度量是指用户开始在页面上看到内容的时间。这意味着所有阻塞渲染的文件都已经加载完成，浏览器已经开始渲染文档模型了。可以通过以下方式优化开始渲染时间：延迟加载阻塞渲染的JavaScript和CSS文件、将关键的CSS代码内联到页面头部、用数据URI代替图片资源，以及延迟加载所有在文档模型渲染完成后才下载的资源。

文档完成时间

只要最初请求的资源已经加载成功，就可以认为文档“完成”了。文档完成时间不包括JavaScript中拉取资源消耗的时间，因此延迟加载的资源不会影响这个指标。



##### 7、文档核心

文档的定义：文档是系统设计的蓝图。没有文档，我们将难免重复解决已经解决过的问题，而且花大量时间查看代码来寻找最简单的答案。没有文档，我们的新员工只能对着系统抓耳挠腮，并怀疑在这种系统中怎么可能完成自己的任务。

写文档是开发工作的一部分，而不是等重要工作完成后才开始的事情。我们需要在开发流程中预留出写文档的时间，用于记录我们开发的代码是如何工作的

###### 静态文档

1. Hologram，为sass js生成文档
2. SassDoc，为sass代码生成文档

可以在代码库中写小段的注释，然后通过它来收集这些注释生成的静态页面。

###### 代码驱动的文档

Pattern Lab