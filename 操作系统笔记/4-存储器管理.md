## 存储器管理

### 1，存储器的层次结构

1. 寄存器，属于CPU寄存器
2. 高速缓存，属于主存
3. 主存储器，属于主存
4. 磁盘缓存，属于主存
5. 固定磁盘，属于辅存
6. 可移动存储介质，属于辅存

在存储器中越靠近CPU，访问速度越快，存储容量也越小

1. 主存储器。用于保存进程运行时的程序和数据，由于主存储器访问速度远低于CPU执行指令的速度，为了缓和这个问题，引入了寄存器和高速缓存。
2. 寄存器。和处理机有相同的速度，所以对寄存器的访问速度最快，完全能与CPU协调工作，但是价格昂贵，容量不大。
3. 高速缓存。主要备份主存中常用的数据，减少处理机对主存储器的访问次数，可以大幅度提高程序执行速度。
4. 磁盘缓存。磁盘的IO速度远低于对主存的访问速度，为了缓和两者之间在速度上的不匹配，出现了磁盘缓存，主要用于存放频繁使用的一部分磁盘数据，以减少磁盘的访问次数。

### 2，程序的装入和链接

程序在运行时，必须先将其装入内存，然后将其转变成一个可执行程序，通常要经过以下三个步骤：

1. 编译：由编译程序对用户源程序进行编译，形成若干个目标模块。
2. 链接：由链接程序将编译后形成的一组目标模块以及他们所需要的库函数链接在一起，形成一个完整的装入模块
3. 装入：由装入程序将装入模块装入内存

**装入**

1. 绝对装入方式

   当计算机系统很小，仅能运行单道程序时，完全有可能知道程序将驻留在内存的什么位置。此时可以采用绝对装入。程序经过编译后，将产生绝对（物理）地址的代码

2. 可重定位装入方式

   绝对装入只能将程序装入内存中事先指定的位置，只适用于单道程序环境。而在多道程序环境下，编译程序不可能预知编译后的目标模块存放的位置，这时可以采用可冲定位装入方式，它可以根据内存的具体情况将装入模块装入到内存得适当位置。

3. 动态运行时装入方式

   可重定位装入方式并不允许程序在运行时在内存中移动位置。比如一个进程可能被多次换出，又被多次换入，每次换入后的位置通常时不同的。这时，可以采用动态运行时装入方式，他把装入模块装入内存后，并不会立即把模块中的逻辑地址转换成物体地址，而是吧地址的转换推迟到程序真正要执行时才进行

**链接**

1. 静态链接方式

   将目标模块及他们所需的库函数链接成一个完整的装配模块，以后不再拆开。

2. 装入时动态链接

   将用户编译后的一组目标模块，在装入内存时，采用边装入边链接的链接方式。

   便于修改和更新。静态链接如果要修改或更新其中的某个目标模块，必须重新打开模块，非常低效，在动态链接中由于各目标模块是分开存放的，所以修改或更新目标模块很容易

   便于实现对目标模块的共享。静态链接中每个模块必须含有目标模块的拷贝，无法实现对目标模块的共享。动态链接很容易讲一个目标模块链接到几个应用模块上，实现共享

3. 运行时动态链接

   对某些模块的链接推迟到程序的执行时才进行。在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找该模块，并装入内存，这样，凡是在执行过程中未被找到的模块，都不会被调入内存和被链接到装入模块上，这样不仅能加快程序的装入，还节省了大量内存空间

### 3，连续分配存储管理方式

​	为了将程序装入内存，必须分配一定大小的内存空间，该分配方式为程序分配一个连续的内存空间，可以理解为，**程序中代码或数据的逻辑地址相邻，体现在内存空间分配时物理地址的相邻**，连续分配方式可以分为四类

1. 单一连续分配

   在单道程序环境下，存储器管理方式是吧内存分为系统区和用户区两部分，系统区仅给OS使用，用户区内存中仅装有一道用户程序，即整个内存的用户空间由该程序独占。

2. 固定分区分配

   为了在内存中装入多道程序，且使这些程序之间不会发生相互干扰，于是将整个用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业。

3. 动态分区分配

   根据进程的实际需要，动态的为之分配内存空间

4. 基于顺序搜索的动态分区分配算法

   为了实现动态分区分配，通常将系统中的内存空间连接成一个链。顺序搜索是指依次搜索空闲分区链上的空闲分区，去找一个其大小能够满足要求的分区。共有四种算法：

   1. 首次适应算法

      在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止。然后按照作业的大小从该分区划出一块内存分配给请求者。

      优点：优先利用内存中地址部分的空闲分区，保留了高址部分的大空闲区。为以后到达的大作也分配大得内存空间创造了条件

      缺点：低址部分不断被划分，会留下许多难以利用的，很小的空闲分区（碎片），而每次查找都是从低址开始的，又增加了查找可用空心分区的开销

   2. 循环首次适应算法

      为了避免首次适应算法的缺点，循环首次适应算法不在每次都从链首开始查找，而是从上次找到的空闲分区的笑一个空闲分区开始查找，直至找到满足要求的空闲分区。

      优点：使内存中空闲分区分布的更均匀，减少了查找空闲分区的开销

      缺点：会缺乏大得空闲分区

   3. 最佳适应算法

      每次为作业分配内存时，总能把满足要求，又是最小的空闲分配给作业，避免大材小用。

      孤立地看，该算法似乎是最佳的，然而宏观上却不一定。因为每次分配后所切割下来的剩余部分总是最小的，会留下很多难以利用的碎片

   4. 最坏适应算法

      与最佳适应算法策略相反，他在扫描链表时，总是挑选一个最大的空间，从中分一部分给作业使用，以至于存储器中缺乏大的空间。

      实际上，该算法未必最坏，优点是可以使剩下的空闲区不至于太小，产生碎片的可能性最小，对中小作业有利。

### 4，分页分段存储管理方式

​	连续分配方式会形成很多**碎片**，如果允许一个进程直接分散地装入到许多不相邻的分区中，便可充分的利用内存空间，基于这个思想产生了离散分配方式。有以下三种方式：

1. 分页存储管理方式

   将用户程序的地址空间分为若干个固定大小的区域，称为页或页面，典型的页面大小为1KB，也就是2e10B，也将内存空间分为若干个物理块或页框，页和块的大小相同，这样可以将用户的任一页放入任一物理块中，实现了离散分配

2. 分段存储管理方式

   为了满足用户要求形成的一种存储管理方式。他把用户程序的地址空间分为若干个大小不同的段，每段可定义一组相对完整的信息。在存储器分配时，以段为单位，这些段在内存中可以不相邻。

3. 段页式存储管理方式

   分页和分段存储管理方式的结合的产物，同时具有两者的优点，目前应用较多。



#### 分页存储管理

##### 基本概念：

1. **页面**：分页存储管理将进程的逻辑空间分成若干个页，并为各页从0开始编号。相应的，吧物理地址分成若干个块。在为进程分配内存时，以块为单位，将进程中分别装入多个不相邻的物理块中。由于进程最后一页经常装不满一块，从而形成了不可利用的页内碎片
2. **页面大小**：若选择的页面过小，虽然可以减小内存碎片，有利于内存利用率的提高，但是没导致每个进程占用较多的页面，从而导致进程页表过长，占用大量内存。因此页面大小应该适中，通常为1-8KB
3. **地址结构**：分页地址的地址结构如下，前一部分为页号，后一部分为页内地址，地址长度为32位，0-11位为页内地址，既每页大小为4KB，12-31位为页号，地址空间最多允许有1M页

![uOethD.md.png](https://s2.ax1x.com/2019/10/12/uOethD.md.png)

**页表**：

​	系统为每个进程简历一张页面映射表，也叫页表，通过查找该表，可以找到每页在内存中的物理块号。页表的作用就是实现页号到物理块号的地址映射

#### 分段存储管理

​	推动前面管理方式的主要目的都是为了提高内存利用率， 而引入分段存储管理则主要是为了满足程序员在编程和使用上的一些要求。

##### 基本概念：

1. **分段**

   作业的地址空间被划分成多个段，每个段定义了一组逻辑信息，比如：主程序段MAIN，子程序段X，数据段D及栈段S

   每个段都从0开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因此各段的长度并不相等

2. **段表**：实现逻辑段到物理内存的映射

   ![uOerHP.md.png](https://s2.ax1x.com/2019/10/12/uOerHP.md.png)

3. **分段地址的地址结构**

   允许一个作业最长有64k个段，每个段的最大长度为64KB

   ![uOeYtO.md.png](https://s2.ax1x.com/2019/10/12/uOeYtO.md.png)

#### 分段的优点：

1. 信息共享。允许若干个进程共享一个或多个分段
2. 方便动态增长。往往存在一些数据段，在使用时数据量会不断增加，他所需的存储空间也要动态增加，但是对于数据段究竟会增长到多大，又不确定，很难采取预先多分配的方式，分段存储可以解决这个问题。
3. 方便动态链接：在程序运行时，当需要某个目标程序时，才将该段调入内存并进行链接

#### 分页和分段的主要区别：

1. 目的不同。分页主要是为了提高内存的利用率，而分段主要是为了更好满足程序员的需要
2. 长度不同。页的大小固定且由系统决定，段的长度不固定，决定于用户所编写的程序



### 5，段页式存储管理方式

段页式存储是对分页和分段这两种管理方式的结合，既有分段系统的优点，又能像分页系统那样解决内存碎片问题。

**原理**：先将用户分成若干个段，再把每个段分成若干个页，并为每个段赋予一个段名

为了实现逻辑地址到物理地址的变换，系统中需要同时配置段表和页表。

![uOeBnI.md.png](https://s2.ax1x.com/2019/10/12/uOeBnI.md.png)

### 6，这三种存储方式的缺点

1. 一次性。作业必须一次性装入内存后才可以运行，导致了大作业无法在小内存中运行。
2. 驻留性。作业被装入内存后，整个作业一直驻留在内存中，其中任何部分都不会被换出，直至作业运行结束，有的程序在运行一次后就不再需要运行了，仍然驻留在内存中，浪费了内存资源。















